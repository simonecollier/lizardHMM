#' Global decoding by the Viterbi algorithm
#'
#' This function takes in data x assumed to be generated by the HMM `hmm` and
#' outputs the most likely sequence of states that could have generated the
#' data using global decoding by the Viterbi algorithm.
#'
#' @param x The data to be fit with an HMM in the form of a 3D array. The
#'   first index (row) corresponds to time, the second (column) to the
#'   variable number, and the third (matrix number) to the subject number.
#' @param hmm A list of parameters that specify the normal HMM, including
#'   `num_states`, `num_variables`, `num_subjects`, `mu`, `sigma`, `gamma`,
#'   `delta`.
#' @param state_dep_dist_pooled A logical variable indiacting whether the
#'   state dependent distribution parameters `mu` and `sigma` should be
#'   treated as equal for all subjects.
#'
#' @return A matrix with each column containing the sequence of states for the
#'   given subject.
#' @export
norm_viterbi <- function(x, hmm, state_dep_dist_pooled = FALSE) {
  n             <- nrow(x)
  num_states    <- hmm$num_states
  num_variables <- hmm$num_variables
  num_subjects  <- hmm$num_subjects
  state_probs   <- list()
  sequence      <- matrix(0, nrow = n, ncol = num_subjects)

  for (i in 1:num_subjects) {
    s_ind   <- i
    if (state_dep_dist_pooled) {
      s_ind <- 1
    }
    state_probs[[i]] <- matrix(0, nrow = n, ncol = num_states)
    P                <- rep(1, num_states)
    for (j in 1:num_variables) {
      P <- P*stats::dnorm(x[1, j, i], hmm$mu[[j]][s_ind, ],
                          hmm$sigma[[j]][s_ind, ])
    }
    forward_probs         <- hmm$delta[[i]]*P
    state_probs[[i]][1, ] <- forward_probs/sum(forward_probs)

    for (t in 2:n) {
      P <- rep(1, num_states)
      for (j in 1:num_variables) {
        P <- P*stats::dnorm(x[t, j, i], hmm$mu[[j]][s_ind, ],
                            hmm$sigma[[j]][s_ind, ])
      }
      if (num_covariates != 0) {
        forward_probs <- apply(state_probs[[i]][t - 1, ]*
                               hmm$gamma[[i]][[t]], 2, max)*P
      } else {
        forward_probs <- apply(state_probs[[i]][t - 1, ]*
                                 hmm$gamma[[i]], 2, max)*P
      }
      state_probs[[i]][t, ] <- forward_probs/sum(forward_probs)
    }
    sequence[n, i] <- which.max(state_probs[[i]][n, ])
    for (t in (n - 1):1){
      sequence[t, i] <- which.max(hmm$gamma[[i]][[t]][, sequence[t + 1]]*
                                    state_probs[[i]][t, ])
    }
  }
  sequence
}
