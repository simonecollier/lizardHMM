norm_viterbi <- function(x, hmm, state_dep_dist_pooled = FALSE) {
  #' Global decoding by the Viterbi algorithm
  #'
  #' This function takes in data x assumed to be generated by the HMM `hmm` and
  #' outputs the most likely sequence of states that could have generated the
  #' data using global decoding by the Viterbi algorithm.
  #'
  #' @inheritParams norm_loglikelihood
  #' @param hmm A list of parameters that specify the normal HMM, including
  #'   `num_states`, `num_variables`, `num_subjects`, `mu`, `sigma`, `gamma`,
  #'   `delta`.
  #'
  #' @return A matrix with each column containing the sequence of states for the
  #'   given subject.
  #' @export

  n             <- nrow(x)
  num_states    <- hmm$num_states
  num_variables <- hmm$num_variables
  num_subjects  <- hmm$num_subjects
  state_probs   <- list()
  sequence      <- matrix(0, nrow = n, ncol = num_subjects)

  for (i in 1:num_subjects) {
    s_ind   <- i
    if (state_dep_dist_pooled) {
      s_ind <- 1
    }
    state_probs[[i]] <- matrix(0, nrow = n, ncol = num_states)
    P                <- rep(1, num_states)
    for (j in 1:num_variables) {
      P <- P*stats::dnorm(x[1, j, i], hmm$mu[[j]][s_ind, ],
                          hmm$sigma[[j]][s_ind, ])
    }
    forward_probs         <- hmm$delta[[i]]*P
    state_probs[[i]][1, ] <- forward_probs/sum(forward_probs)

    for (t in 2:n) {
      P <- rep(1, num_states)
      for (j in 1:num_variables) {
        P <- P*stats::dnorm(x[t, j, i], hmm$mu[[j]][s_ind, ],
                            hmm$sigma[[j]][s_ind, ])
      }
      forward_probs <- apply(state_probs[[i]][t - 1, ]*
                               hmm$gamma[[i]][[t]], 2, max)*P
      state_probs[[i]][t, ] <- forward_probs/sum(forward_probs)
    }
    sequence[n, i] <- which.max(state_probs[[i]][n, ])
    for (t in (n - 1):1){
      sequence[t, i] <- which.max(hmm$gamma[[i]][[t]][, sequence[t + 1]]*
                                    state_probs[[i]][t, ])
    }
  }
  sequence
}
